use std::marker::PhantomData;

use crate::deciders::Decider;
use crate::utilities::{FallibleConverter, InfallibleConverter};

/// A trait representing a Process
///
/// A process is a type that takes in event of type `E` and a state of type `S`, and returns
/// commands of type `C`. The events are also used to update (or "evolve") the state into a new
/// state.
///
/// Processes can be used along with deciders to implement a sort of feedback loop, where the
/// decider takes in commands and outputs events, that are then passed into the process to generate
/// new commands for the decider. This pattern is already implemented in
/// [`CombinedProcessDecider`].
///
/// Note that all methods defined on this trait do not take self, so it is useless to make a
/// concrete instance of an object with this trait.
pub trait Process<E, C, S> {
    /// Given an event `event` and the current state `state`, returns the new state of the process.
    fn evolve(state: &S, event: &E) -> S;

    /// Given a state `state`, returns a list of commands that transition this process from the
    /// initial state to this state.
    fn resume(state: &S) -> Vec<C>;

    /// Given the current state `state` and an incoming event `event`, reurns a new list of
    /// commands in reaction to that event.
    fn react(state: &S, event: &E) -> Vec<C>;

    /// Returns the initial state this process should start in.
    fn initial_state() -> S;

    /// Given the current state `state`, returns whether this state represents an end state for
    /// this process.
    fn is_terminal(state: &S) -> bool;
}

/// Adapts a process to use different command and event types.
///
/// This type allows for converting a process that implements `Process<Eo, Ci, S>` into a
/// decider that implements `Process<Ei, Co, S>`.
///
/// It does this by taking 2 additional "converter" types, that can convert to and from the
/// decider's native types into the new types:
///
/// - `CC` - The command converter that implements [`InfallibleConverter`], which converts the
///   process' *native* command type into the *new* command type.
/// - `EC` - The event converter that implements [`FallibleConverter`], which converts the *new* event
///   type into the process' *native* event type, with the option of failure.
pub struct AdaptedProcess<P, Ei, Eo, Ci, Co, S, EC, CC>
where
    P: Process<Eo, Ci, S>,
    EC: FallibleConverter<Ei, Eo>,
    CC: InfallibleConverter<Ci, Co>,
{
    process: PhantomData<P>,
    input_event: PhantomData<Ei>,
    output_event: PhantomData<Eo>,
    input_command: PhantomData<Ci>,
    output_command: PhantomData<Co>,
    state: PhantomData<S>,
    event_converter: PhantomData<EC>,
    command_converter: PhantomData<CC>,
}

impl<P, Ei, Eo, Ci, Co, S, EC, CC> Process<Ei, Co, S>
    for AdaptedProcess<P, Ei, Eo, Ci, Co, S, EC, CC>
where
    P: Process<Eo, Ci, S>,
    S: Copy + Clone,
    EC: FallibleConverter<Ei, Eo>,
    CC: InfallibleConverter<Ci, Co>,
{
    fn evolve(state: &S, event: &Ei) -> S {
        match EC::convert(event) {
            Some(e) => <P as Process<_, _, _>>::evolve(state, &e),
            None => *state,
        }
    }

    fn resume(state: &S) -> Vec<Co> {
        P::resume(state)
            .into_iter()
            .map(|c| CC::convert(&c))
            .collect()
    }

    fn react(state: &S, event: &Ei) -> Vec<Co> {
        match EC::convert(event) {
            Some(e) => P::react(state, &e)
                .into_iter()
                .map(|c| CC::convert(&c))
                .collect(),
            None => vec![],
        }
    }

    fn initial_state() -> S {
        P::initial_state()
    }

    fn is_terminal(state: &S) -> bool {
        P::is_terminal(state)
    }
}

/// This is a helper method for passing a slice of events into a processes.
///
/// This is a simple method that loops over a slice of events, calling `P::evolve` and `P::react`
/// on each, and collecting all of the resulting commands into a single vector.
///
/// > *NOTE*: While this internally keeps track of state changes to the process, that state is not
/// > returned to the caller!
pub fn collect_fold<P, E, C, S>(state: &S, events: &[E]) -> Vec<C>
where
    P: Process<E, C, S>,
    S: Copy + Clone,
{
    let mut s = *state;
    let mut all_commands = vec![];
    for event in events {
        s = P::evolve(&s, event);
        all_commands.extend(P::react(&s, event));
    }
    all_commands
}

/// This type combines a Decider and a Process, feeding the events generated by the decider into
/// the process, and feeding the commands generated from the process back into the decider. This
/// results in a new type that implements the [`crate::deciders::Decider`] trait.
///
/// Both the decider and the process must comsume the same command type `C` and event type `E`. The
/// new state type used by `CombinedProcessDecider` will be a tuple of the decider's state and the
/// process' state.
///
/// > *NOTE*: Since there are no calls to evolve in decide, the states of the decider and the
pub struct CombinedProcessDecider<P, D, E, C, Sp, Sd>
where
    P: Process<E, C, Sp>,
    D: Decider<C, E, Sd, Sd>,
{
    process: PhantomData<P>,
    decider: PhantomData<D>,
    event: PhantomData<E>,
    command: PhantomData<C>,
    state_process: PhantomData<Sp>,
    state_decider: PhantomData<Sd>,
}

impl<P, D, E, C, Sp, Sd> Decider<C, E, (Sp, Sd), (Sp, Sd)>
    for CombinedProcessDecider<P, D, E, C, Sp, Sd>
where
    Sp: Copy + Clone,
    C: Copy + Clone,
    P: Process<E, C, Sp>,
    D: Decider<C, E, Sd, Sd>,
{
    fn decide(command: &C, (state_process, state_decider): &(Sp, Sd)) -> Vec<E> {
        let mut commands = vec![*command];
        let mut all_events = vec![];
        while !commands.is_empty() {
            let c = commands.remove(0);
            let events = D::decide(&c, state_decider);
            commands.extend(collect_fold::<P, E, C, Sp>(state_process, &events));
            all_events.extend(events);
        }
        all_events
    }

    fn evolve((state_process, state_decider): &(Sp, Sd), event: &E) -> (Sp, Sd) {
        (
            P::evolve(state_process, event),
            D::evolve(state_decider, event),
        )
    }

    fn initial_state() -> (Sp, Sd) {
        (P::initial_state(), D::initial_state())
    }

    fn is_terminal((state_process, state_decider): &(Sp, Sd)) -> bool {
        P::is_terminal(state_process) && D::is_terminal(state_decider)
    }
}
